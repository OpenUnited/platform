{
  "admin": {
    "LogEntry": {
      "fields": {
        "id": {
          "type": "AutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "action_time": {
          "type": "DateTimeField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "user": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "User",
            "app": "security",
            "on_delete": "CASCADE"
          }
        },
        "content_type": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ContentType",
            "app": "contenttypes",
            "on_delete": "SET_NULL"
          }
        },
        "object_id": {
          "type": "TextField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "object_repr": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "action_flag": {
          "type": "PositiveSmallIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "Addition",
            "2": "Change",
            "3": "Deletion"
          }
        },
        "change_message": {
          "type": "TextField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_action_flag_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.PositiveSmallIntegerField: action_flag>)"
        },
        "get_admin_url": {
          "doc": "Return the admin URL to edit the object represented by this log entry.",
          "signature": "(self)"
        },
        "get_change_message": {
          "doc": "If self.change_message is a JSON structure, interpret it as a change\nstring, properly translated.",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_edited_object": {
          "doc": "Return the edited object represented by this log entry.",
          "signature": "(self)"
        },
        "get_next_by_action_time": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: action_time>, is_next=True, **kwargs)"
        },
        "get_previous_by_action_time": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: action_time>, is_next=False, **kwargs)"
        },
        "is_addition": {
          "doc": "None",
          "signature": "(self)"
        },
        "is_change": {
          "doc": "None",
          "signature": "(self)"
        },
        "is_deletion": {
          "doc": "None",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [
          "-action_time"
        ],
        "unique_together": [],
        "verbose_name": "log entry",
        "verbose_name_plural": "log entries",
        "abstract": false,
        "db_table": "django_admin_log"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "LogEntry(id, action_time, user, content_type, object_id, object_repr, action_flag, change_message)",
      "app_label": "admin"
    }
  },
  "auth": {
    "Permission": {
      "fields": {
        "group": {
          "type": "ManyToManyField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "user": {
          "type": "ManyToManyField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "AutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "name": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "content_type": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ContentType",
            "app": "contenttypes",
            "on_delete": "CASCADE"
          }
        },
        "codename": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "natural_key": {
          "doc": "None",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [
          "content_type__app_label",
          "content_type__model",
          "codename"
        ],
        "unique_together": [
          [
            "content_type",
            "codename"
          ]
        ],
        "verbose_name": "permission",
        "verbose_name_plural": "permissions",
        "abstract": false,
        "db_table": "auth_permission"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "group": {
          "type": "ManyToManyRel",
          "model": "Group",
          "app": "auth",
          "related_name": null,
          "related_query_name": "group",
          "many_to_many": true,
          "one_to_many": false,
          "one_to_one": false
        },
        "user": {
          "type": "ManyToManyRel",
          "model": "User",
          "app": "security",
          "related_name": null,
          "related_query_name": "user",
          "many_to_many": true,
          "one_to_many": false,
          "one_to_one": false
        }
      },
      "doc": "\n    The permissions system provides a way to assign permissions to specific\n    users and groups of users.\n\n    The permission system is used by the Django admin site, but may also be\n    useful in your own code. The Django admin site uses permissions as follows:\n\n        - The \"add\" permission limits the user's ability to view the \"add\" form\n          and add an object.\n        - The \"change\" permission limits a user's ability to view the change\n          list, view the \"change\" form and change an object.\n        - The \"delete\" permission limits the ability to delete an object.\n        - The \"view\" permission limits the ability to view an object.\n\n    Permissions are set globally per type of object, not per specific object\n    instance. It is possible to say \"Mary may change news stories,\" but it's\n    not currently possible to say \"Mary may change news stories, but only the\n    ones she created herself\" or \"Mary may only change news stories that have a\n    certain status or publication date.\"\n\n    The permissions listed above are automatically created for each model.\n    ",
      "app_label": "auth"
    },
    "Group": {
      "fields": {
        "user": {
          "type": "ManyToManyField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "AutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "name": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "permissions": {
          "type": "ManyToManyField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Permission",
            "app": "auth",
            "through": "Group_permissions"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "natural_key": {
          "doc": "None",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "group",
        "verbose_name_plural": "groups",
        "abstract": false,
        "db_table": "auth_group"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "user": {
          "type": "ManyToManyRel",
          "model": "User",
          "app": "security",
          "related_name": null,
          "related_query_name": "user",
          "many_to_many": true,
          "one_to_many": false,
          "one_to_one": false
        }
      },
      "doc": "\n    Groups are a generic way of categorizing users to apply permissions, or\n    some other label, to those users. A user can belong to any number of\n    groups.\n\n    A user in a group automatically has all the permissions granted to that\n    group. For example, if the group 'Site editors' has the permission\n    can_edit_home_page, any user in that group will have that permission.\n\n    Beyond permissions, groups are a convenient way to categorize users to\n    apply some label, or extended functionality, to them. For example, you\n    could create a group 'Special users', and you could write code that would\n    do special things to those users -- such as giving them access to a\n    members-only portion of your site, or sending them members-only email\n    messages.\n    ",
      "app_label": "auth"
    }
  },
  "contenttypes": {
    "ContentType": {
      "fields": {
        "logentry": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "permission": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "AutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "app_label": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "model": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_all_objects_for_this_type": {
          "doc": "Return all objects of this type for the keyword arguments given.",
          "signature": "(self, **kwargs)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_object_for_this_type": {
          "doc": "Return an object of this type for the keyword arguments given.\nBasically, this is a proxy around this object_type's get_object() model\nmethod. The ObjectNotExist exception, if thrown, will not be caught,\nso code that calls this method should catch it.",
          "signature": "(self, **kwargs)"
        },
        "model_class": {
          "doc": "Return the model class for this type of content.",
          "signature": "(self)"
        },
        "natural_key": {
          "doc": "None",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [
          [
            "app_label",
            "model"
          ]
        ],
        "verbose_name": "content type",
        "verbose_name_plural": "content types",
        "abstract": false,
        "db_table": "django_content_type"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "logentry": {
          "type": "ManyToOneRel",
          "model": "LogEntry",
          "app": "admin",
          "related_name": null,
          "related_query_name": "logentry",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "permission": {
          "type": "ManyToOneRel",
          "model": "Permission",
          "app": "auth",
          "related_name": null,
          "related_query_name": "permission",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "ContentType(id, app_label, model)",
      "app_label": "contenttypes"
    }
  },
  "sessions": {
    "Session": {
      "fields": {
        "session_key": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "session_data": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "expire_date": {
          "type": "DateTimeField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_decoded": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_next_by_expire_date": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: expire_date>, is_next=True, **kwargs)"
        },
        "get_previous_by_expire_date": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: expire_date>, is_next=False, **kwargs)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "session",
        "verbose_name_plural": "sessions",
        "abstract": false,
        "db_table": "django_session"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "\n    Django provides full support for anonymous sessions. The session\n    framework lets you store and retrieve arbitrary data on a\n    per-site-visitor basis. It stores data on the server side and\n    abstracts the sending and receiving of cookies. Cookies contain a\n    session ID -- not the data itself.\n\n    The Django sessions framework is entirely cookie-based. It does\n    not fall back to putting session IDs in URLs. This is an intentional\n    design decision. Not only does that behavior make URLs ugly, it makes\n    your site vulnerable to session-ID theft via the \"Referer\" header.\n\n    For complete documentation on using Sessions in your code, consult\n    the sessions documentation that is shipped with Django (also available\n    on the Django web site).\n    ",
      "app_label": "sessions"
    }
  },
  "product_management": {
    "FileAttachment": {
      "fields": {
        "productarea": {
          "type": "ManyToManyField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "product": {
          "type": "ManyToManyField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "challenge": {
          "type": "ManyToManyField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "bounty": {
          "type": "ManyToManyField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "bountydeliveryattempt": {
          "type": "ManyToManyField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "file": {
          "type": "FileField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "file attachment",
        "verbose_name_plural": "file attachments",
        "abstract": false,
        "db_table": "product_management_fileattachment"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "productarea": {
          "type": "ManyToManyRel",
          "model": "ProductArea",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "productarea",
          "many_to_many": true,
          "one_to_many": false,
          "one_to_one": false
        },
        "product": {
          "type": "ManyToManyRel",
          "model": "Product",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "product",
          "many_to_many": true,
          "one_to_many": false,
          "one_to_one": false
        },
        "challenge": {
          "type": "ManyToManyRel",
          "model": "Challenge",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "challenge",
          "many_to_many": true,
          "one_to_many": false,
          "one_to_one": false
        },
        "bounty": {
          "type": "ManyToManyRel",
          "model": "Bounty",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "bounty",
          "many_to_many": true,
          "one_to_many": false,
          "one_to_one": false
        },
        "bountydeliveryattempt": {
          "type": "ManyToManyRel",
          "model": "BountyDeliveryAttempt",
          "app": "talent",
          "related_name": null,
          "related_query_name": "bountydeliveryattempt",
          "many_to_many": true,
          "one_to_many": false,
          "one_to_one": false
        }
      },
      "doc": "FileAttachment(id, file)",
      "app_label": "product_management"
    },
    "ProductTree": {
      "fields": {
        "product_areas": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "name": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "session_id": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "product": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Product",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [
          "-created_at"
        ],
        "unique_together": [],
        "verbose_name": "product tree",
        "verbose_name_plural": "product trees",
        "abstract": false,
        "db_table": "product_management_producttree"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "product_areas": {
          "type": "ManyToOneRel",
          "model": "ProductArea",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "product_areas",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "ProductTree(id, created_at, updated_at, name, session_id, product)",
      "app_label": "product_management"
    },
    "ProductArea": {
      "fields": {
        "challenge": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "path": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "depth": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "numchild": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "name": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "description": {
          "type": "TextField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "video_link": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "video_name": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "video_duration": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "product_tree": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ProductTree",
            "app": "product_management",
            "on_delete": "SET_NULL"
          }
        },
        "comments_start": {
          "type": "ForeignKey",
          "null": true,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "CapabilityComment",
            "app": "talent",
            "on_delete": "SET_NULL"
          }
        },
        "attachments": {
          "type": "ManyToManyField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "FileAttachment",
            "app": "product_management",
            "through": "ProductArea_attachments"
          }
        }
      },
      "methods": {
        "add_child": {
          "doc": "Adds a child to the node.\n\nThis method saves the node in database. The object is populated as if via:\n\n```\nobj = self.__class__(**kwargs)\n```\n\n:raise PathOverflow: when no more child nodes can be added",
          "signature": "(self, **kwargs)"
        },
        "add_sibling": {
          "doc": "Adds a new node as a sibling to the current node object.\n\nThis method saves the node in database. The object is populated as if via:\n\n```\nobj = self.__class__(**kwargs)\n```\n\n:raise PathOverflow: when the library can't make room for the\n   node's new position",
          "signature": "(self, pos=None, **kwargs)"
        },
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "Removes a node and all it's descendants.",
          "signature": "(self, *args, **kwargs)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_ancestors": {
          "doc": ":returns: A queryset containing the current node object's ancestors,\n    starting by the root node and descending to the parent.",
          "signature": "(self)"
        },
        "get_children": {
          "doc": ":returns: A queryset of all the node's children",
          "signature": "(self)"
        },
        "get_children_count": {
          "doc": ":returns: The number the node's children, calculated in the most\nefficient possible way.",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_depth": {
          "doc": ":returns: the depth (level) of the node",
          "signature": "(self)"
        },
        "get_descendant_count": {
          "doc": ":returns: the number of descendants of a node.",
          "signature": "(self)"
        },
        "get_descendants": {
          "doc": ":returns: A queryset of all the node's descendants as DFS, doesn't\n    include the node itself",
          "signature": "(self)"
        },
        "get_first_child": {
          "doc": ":returns:\n\n    The leftmost node's child, or None if it has no children.",
          "signature": "(self)"
        },
        "get_first_sibling": {
          "doc": ":returns:\n\n    The leftmost node's sibling, can return the node itself if\n    it was the leftmost sibling.",
          "signature": "(self)"
        },
        "get_last_child": {
          "doc": ":returns:\n\n    The rightmost node's child, or None if it has no children.",
          "signature": "(self)"
        },
        "get_last_sibling": {
          "doc": ":returns:\n\n    The rightmost node's sibling, can return the node itself if\n    it was the rightmost sibling.",
          "signature": "(self)"
        },
        "get_next_sibling": {
          "doc": ":returns: The next node's sibling, or None if it was the rightmost\n    sibling.",
          "signature": "(self)"
        },
        "get_parent": {
          "doc": ":returns: the parent node of the current node object.\n    Caches the result in the object itself to help in loops.",
          "signature": "(self, update=False)"
        },
        "get_prev_sibling": {
          "doc": ":returns: The previous node's sibling, or None if it was the leftmost\n    sibling.",
          "signature": "(self)"
        },
        "get_root": {
          "doc": ":returns: the root node for the current node object.",
          "signature": "(self)"
        },
        "get_siblings": {
          "doc": ":returns: A queryset of all the node's siblings, including the node\n    itself.",
          "signature": "(self)"
        },
        "get_sorted_pos_queryset": {
          "doc": ":returns:\n\n    A queryset of the nodes that must be moved to the right.\n    Called only for Node models with :attr:`node_order_by`\n\nThis function is based on _insertion_target_filters from django-mptt\n(BSD licensed) by Jonathan Buchanan:\nhttps://github.com/django-mptt/django-mptt/blob/0.3.0/mptt/signals.py",
          "signature": "(self, siblings, newobj)"
        },
        "is_child_of": {
          "doc": ":returns: ``True`` is the node if a child of another node given as an\n    argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "is_descendant_of": {
          "doc": ":returns: ``True`` if the node is a descendant of another node given\n    as an argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "is_leaf": {
          "doc": ":returns: True if the node is a leaf node (else, returns False)",
          "signature": "(self)"
        },
        "is_root": {
          "doc": ":returns: True if the node is a root node (else, returns False)",
          "signature": "(self)"
        },
        "is_sibling_of": {
          "doc": ":returns: ``True`` if the node is a sibling of another node given as an\n    argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "move": {
          "doc": "Moves the current node and all it's descendants to a new position\nrelative to another node.\n\n:raise PathOverflow: when the library can't make room for the\n   node's new position",
          "signature": "(self, target, pos=None)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "product area",
        "verbose_name_plural": "product areas",
        "abstract": false,
        "db_table": "product_management_productarea"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "challenge": {
          "type": "ManyToOneRel",
          "model": "Challenge",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "challenge",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "ProductArea(id, path, depth, numchild, created_at, updated_at, name, description, video_link, video_name, video_duration, product_tree, comments_start)",
      "app_label": "product_management"
    },
    "Product": {
      "fields": {
        "product_trees": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "initiatives": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "challenge": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "productchallenge": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "product_contributor_guide": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "idea": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "bug": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "contributor_agreement_templates": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "role_assignments": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "productaccount": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "photo": {
          "type": "FileField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "name": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "short_description": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "full_description": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "website": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "detail_url": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "video_url": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "slug": {
          "type": "SlugField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "is_private": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "person": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "organisation": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Organisation",
            "app": "commerce",
            "on_delete": "SET_NULL"
          }
        },
        "visibility": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "GLOBAL": "Global",
            "ORG_ONLY": "Organisation Only",
            "RESTRICTED": "Restricted"
          }
        },
        "attachments": {
          "type": "ManyToManyField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "FileAttachment",
            "app": "product_management",
            "through": "Product_attachments"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "can_user_manage": {
          "doc": "Check if a user can manage this product",
          "signature": "(self, user) -> bool"
        },
        "clean": {
          "doc": "Validate that only one owner type is set",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, *args, **kwargs)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_absolute_url": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_initials_of_name": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_photo_url": {
          "doc": "Get the product photo URL or default image",
          "signature": "(self)"
        },
        "get_visibility_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.CharField: visibility>)"
        },
        "has_changed": {
          "doc": "Check if a field has changed since the model value instantiated.",
          "signature": "(self, field_name: 'str') -> 'bool'"
        },
        "initial_value": {
          "doc": "Get initial value of field when model value instantiated.",
          "signature": "(self, field_name: 'str') -> 'Any'"
        },
        "is_owned_by_organisation": {
          "doc": "Check if product is owned by an organisation",
          "signature": "(self) -> bool"
        },
        "is_owned_by_person": {
          "doc": "Check if product is owned by an individual person",
          "signature": "(self) -> bool"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, *args, **kwargs)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "update_slug": {
          "doc": "None",
          "signature": "(self, *args, **kwargs)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "product",
        "verbose_name_plural": "products",
        "abstract": false,
        "db_table": "product_management_product"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "product_trees": {
          "type": "ManyToOneRel",
          "model": "ProductTree",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "product_trees",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "initiatives": {
          "type": "ManyToOneRel",
          "model": "Initiative",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "initiatives",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "challenge": {
          "type": "ManyToOneRel",
          "model": "Challenge",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "challenge",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "productchallenge": {
          "type": "ManyToOneRel",
          "model": "ProductChallenge",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "productchallenge",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "product_contributor_guide": {
          "type": "ManyToOneRel",
          "model": "ContributorGuide",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "product_contributor_guide",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "idea": {
          "type": "ManyToOneRel",
          "model": "Idea",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "idea",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "bug": {
          "type": "ManyToOneRel",
          "model": "Bug",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "bug",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "contributor_agreement_templates": {
          "type": "ManyToOneRel",
          "model": "ProductContributorAgreementTemplate",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "contributor_agreement_templates",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "role_assignments": {
          "type": "ManyToOneRel",
          "model": "ProductRoleAssignment",
          "app": "security",
          "related_name": null,
          "related_query_name": "role_assignments",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "productaccount": {
          "type": "ManyToOneRel",
          "model": "ProductAccount",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "productaccount",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "Product(id, created_at, updated_at, uuid, photo, name, short_description, full_description, website, detail_url, video_url, slug, is_private, person, organisation, visibility)",
      "app_label": "product_management"
    },
    "Initiative": {
      "fields": {
        "challenge": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "name": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "product": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Product",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "description": {
          "type": "TextField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "status": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "Draft": "Draft",
            "Active": "Active",
            "Completed": "Completed",
            "Cancelled": "Cancelled"
          }
        },
        "video_url": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_available_challenges_count": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_challenge_tags": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_completed_challenges_count": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_filtered_data": {
          "doc": "None",
          "signature": "(input_data, filter_data=None, exclude_data=None)"
        },
        "get_status_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.CharField: status>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, *args, **kwargs)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "initiative",
        "verbose_name_plural": "initiatives",
        "abstract": false,
        "db_table": "product_management_initiative"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "challenge": {
          "type": "ManyToOneRel",
          "model": "Challenge",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "challenge",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "Initiative(id, created_at, updated_at, uuid, name, product, description, status, video_url)",
      "app_label": "product_management"
    },
    "Challenge": {
      "fields": {
        "bounty": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "challengedependency": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "Challenge": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "productchallenge": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "initiative": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Initiative",
            "app": "product_management",
            "on_delete": "SET_NULL"
          }
        },
        "product_area": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ProductArea",
            "app": "product_management",
            "on_delete": "SET_NULL"
          }
        },
        "title": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "description": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "short_description": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "status": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "Draft": "Draft",
            "Blocked": "Blocked",
            "Active": "Active",
            "Completed": "Completed",
            "Cancelled": "Cancelled"
          }
        },
        "blocked": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "featured": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "priority": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "High": "High",
            "Medium": "Medium",
            "Low": "Low"
          }
        },
        "published_id": {
          "type": "IntegerField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "auto_approve_task_claims": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "created_by": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "updated_by": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "comments_start": {
          "type": "ForeignKey",
          "null": true,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ChallengeComment",
            "app": "talent",
            "on_delete": "SET_NULL"
          }
        },
        "product": {
          "type": "ForeignKey",
          "null": true,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Product",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "video_url": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "contribution_guide": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ContributorGuide",
            "app": "product_management",
            "on_delete": "SET_NULL"
          }
        },
        "reward_type": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "Liquid Points": "Liquid Points",
            "Non-liquid Points": "Non Liquid Points"
          }
        },
        "attachments": {
          "type": "ManyToManyField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "FileAttachment",
            "app": "product_management",
            "through": "Challenge_attachments"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "can_delete_challenge": {
          "doc": "None",
          "signature": "(self, person)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_absolute_url": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_bounty_points": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_filtered_data": {
          "doc": "None",
          "signature": "(input_data, filter_data=None, exclude_data=None)"
        },
        "get_priority_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.CharField: priority>)"
        },
        "get_reward_type_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.CharField: reward_type>)"
        },
        "get_short_description": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_status_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.CharField: status>)"
        },
        "has_bounty": {
          "doc": "None",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "challenge",
        "verbose_name_plural": "Challenges",
        "abstract": false,
        "db_table": "product_management_challenge"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "bounty": {
          "type": "ManyToOneRel",
          "model": "Bounty",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "bounty",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "challengedependency": {
          "type": "ManyToOneRel",
          "model": "ChallengeDependency",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "challengedependency",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "Challenge": {
          "type": "ManyToOneRel",
          "model": "ChallengeDependency",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "Challenge",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "productchallenge": {
          "type": "ManyToOneRel",
          "model": "ProductChallenge",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "productchallenge",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "Challenge(id, created_at, updated_at, uuid, initiative, product_area, title, description, short_description, status, blocked, featured, priority, published_id, auto_approve_task_claims, created_by, updated_by, comments_start, product, video_url, contribution_guide, reward_type)",
      "app_label": "product_management"
    },
    "Bounty": {
      "fields": {
        "bountyclaim": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "title": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "challenge": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Challenge",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "description": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "skill": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Skill",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "points": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "status": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "Available": "Available",
            "Claimed": "Claimed",
            "In Review": "In Review",
            "Completed": "Completed",
            "Cancelled": "Cancelled"
          }
        },
        "is_active": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "claimed_by": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "attachments": {
          "type": "ManyToManyField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "FileAttachment",
            "app": "product_management",
            "through": "Bounty_attachments"
          }
        },
        "expertise": {
          "type": "ManyToManyField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Expertise",
            "app": "talent",
            "through": "Bounty_expertise"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_expertise_as_str": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_status_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.CharField: status>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [
          "-created_at"
        ],
        "unique_together": [],
        "verbose_name": "bounty",
        "verbose_name_plural": "bountys",
        "abstract": false,
        "db_table": "product_management_bounty"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "bountyclaim": {
          "type": "ManyToOneRel",
          "model": "BountyClaim",
          "app": "talent",
          "related_name": null,
          "related_query_name": "bountyclaim",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "Bounty(id, created_at, updated_at, title, challenge, description, skill, points, status, is_active, claimed_by)",
      "app_label": "product_management"
    },
    "ChallengeDependency": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "preceding_challenge": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Challenge",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "subsequent_challenge": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Challenge",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "challenge dependency",
        "verbose_name_plural": "challenge dependencys",
        "abstract": false,
        "db_table": "product_management_challenge_dependencies"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "ChallengeDependency(id, preceding_challenge, subsequent_challenge)",
      "app_label": "product_management"
    },
    "ProductChallenge": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "product": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Product",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "challenge": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Challenge",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "product challenge",
        "verbose_name_plural": "product challenges",
        "abstract": false,
        "db_table": "product_management_productchallenge"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "ProductChallenge(id, created_at, updated_at, uuid, product, challenge)",
      "app_label": "product_management"
    },
    "ContributorGuide": {
      "fields": {
        "challenge": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "product": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Product",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "title": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "description": {
          "type": "TextField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "skill": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Skill",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "contributor guide",
        "verbose_name_plural": "contributor guides",
        "abstract": false,
        "db_table": "product_management_contributorguide"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "challenge": {
          "type": "ManyToOneRel",
          "model": "Challenge",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "challenge",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "ContributorGuide(id, product, title, description, skill)",
      "app_label": "product_management"
    },
    "Idea": {
      "fields": {
        "ideavote": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "title": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "description": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "product": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Product",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "person": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_absolute_url": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "idea",
        "verbose_name_plural": "ideas",
        "abstract": false,
        "db_table": "product_management_idea"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "ideavote": {
          "type": "ManyToOneRel",
          "model": "IdeaVote",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "ideavote",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "Idea(id, created_at, updated_at, title, description, product, person)",
      "app_label": "product_management"
    },
    "Bug": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "title": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "description": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "product": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Product",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "person": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_absolute_url": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "bug",
        "verbose_name_plural": "bugs",
        "abstract": false,
        "db_table": "product_management_bug"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "Bug(id, created_at, updated_at, title, description, product, person)",
      "app_label": "product_management"
    },
    "ProductContributorAgreementTemplate": {
      "fields": {
        "productcontributoragreement": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "product": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Product",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "title": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "content": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "effective_date": {
          "type": "DateField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "created_by": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_next_by_effective_date": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateField: effective_date>, is_next=True, **kwargs)"
        },
        "get_previous_by_effective_date": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateField: effective_date>, is_next=False, **kwargs)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [
          "-created_at"
        ],
        "unique_together": [],
        "verbose_name": "product contributor agreement template",
        "verbose_name_plural": "product contributor agreement templates",
        "abstract": false,
        "db_table": "product_management_productcontributoragreementtemplate"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "productcontributoragreement": {
          "type": "ManyToOneRel",
          "model": "ProductContributorAgreement",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "productcontributoragreement",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "ProductContributorAgreementTemplate(id, created_at, updated_at, product, title, content, effective_date, created_by)",
      "app_label": "product_management"
    },
    "IdeaVote": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "voter": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "User",
            "app": "security",
            "on_delete": "CASCADE"
          }
        },
        "idea": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Idea",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [
          [
            "voter",
            "idea"
          ]
        ],
        "verbose_name": "idea vote",
        "verbose_name_plural": "idea votes",
        "abstract": false,
        "db_table": "product_management_ideavote"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "IdeaVote(id, created_at, updated_at, voter, idea)",
      "app_label": "product_management"
    },
    "ProductContributorAgreement": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "agreement_template": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ProductContributorAgreementTemplate",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "person": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "accepted_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "product contributor agreement",
        "verbose_name_plural": "product contributor agreements",
        "abstract": false,
        "db_table": "product_management_productcontributoragreement"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "ProductContributorAgreement(id, created_at, updated_at, agreement_template, person, accepted_at)",
      "app_label": "product_management"
    }
  },
  "security": {
    "User": {
      "fields": {
        "logentry": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "ideavote": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "signuprequest": {
          "type": "OneToOneField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "signinattempt": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "person": {
          "type": "OneToOneField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "social_auth": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "password": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "last_login": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "is_superuser": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "Designates that this user has all permissions without explicitly assigning them.",
          "choices": null
        },
        "username": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.",
          "choices": null
        },
        "first_name": {
          "type": "CharField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "last_name": {
          "type": "CharField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "email": {
          "type": "CharField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "is_staff": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "Designates whether the user can log into this admin site.",
          "choices": null
        },
        "is_active": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "Designates whether this user should be treated as active. Unselect this instead of deleting accounts.",
          "choices": null
        },
        "date_joined": {
          "type": "DateTimeField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "remaining_budget_for_failed_logins": {
          "type": "PositiveSmallIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "password_reset_required": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "is_test_user": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "groups": {
          "type": "ManyToManyField",
          "null": false,
          "blank": true,
          "help_text": "The groups this user belongs to. A user will get all permissions granted to each of their groups.",
          "choices": null,
          "references": {
            "model": "Group",
            "app": "auth",
            "through": "User_groups"
          }
        },
        "user_permissions": {
          "type": "ManyToManyField",
          "null": false,
          "blank": true,
          "help_text": "Specific permissions for this user.",
          "choices": null,
          "references": {
            "model": "Permission",
            "app": "auth",
            "through": "User_user_permissions"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "check_password": {
          "doc": "Return a boolean of whether the raw_password was correct. Handles\nhashing formats behind the scenes.",
          "signature": "(self, raw_password)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "email_user": {
          "doc": "Send an email to this user.",
          "signature": "(self, subject, message, from_email=None, **kwargs)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_all_permissions": {
          "doc": "None",
          "signature": "(self, obj=None)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_full_name": {
          "doc": "Return the first_name plus the last_name, with a space in between.",
          "signature": "(self)"
        },
        "get_group_permissions": {
          "doc": "Return a list of permission strings that this user has through their\ngroups. Query all available auth backends. If an object is passed in,\nreturn only permissions matching this object.",
          "signature": "(self, obj=None)"
        },
        "get_next_by_date_joined": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: date_joined>, is_next=True, **kwargs)"
        },
        "get_previous_by_date_joined": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: date_joined>, is_next=False, **kwargs)"
        },
        "get_session_auth_fallback_hash": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_session_auth_hash": {
          "doc": "Return an HMAC of the password field.",
          "signature": "(self)"
        },
        "get_short_name": {
          "doc": "Return the short name for the user.",
          "signature": "(self)"
        },
        "get_user_permissions": {
          "doc": "Return a list of permission strings that this user has directly.\nQuery all available auth backends. If an object is passed in,\nreturn only permissions matching this object.",
          "signature": "(self, obj=None)"
        },
        "get_username": {
          "doc": "Return the username for this User.",
          "signature": "(self)"
        },
        "has_module_perms": {
          "doc": "Return True if the user has any permissions in the given app label.\nUse similar logic as has_perm(), above.",
          "signature": "(self, app_label)"
        },
        "has_perm": {
          "doc": "Return True if the user has the specified permission. Query all\navailable auth backends, but return immediately if any backend returns\nTrue. Thus, a user who has permission from a single auth backend is\nassumed to have permission in general. If an object is provided, check\npermissions for that object.",
          "signature": "(self, perm, obj=None)"
        },
        "has_perms": {
          "doc": "Return True if the user has each of the specified permissions. If\nobject is passed, check if the user has all required perms for it.",
          "signature": "(self, perm_list, obj=None)"
        },
        "has_usable_password": {
          "doc": "Return False if set_unusable_password() has been called for this user.",
          "signature": "(self)"
        },
        "natural_key": {
          "doc": "None",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "reset_remaining_budget_for_failed_logins": {
          "doc": "None",
          "signature": "(self)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, *args, **kwargs)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "set_password": {
          "doc": "None",
          "signature": "(self, raw_password)"
        },
        "set_unusable_password": {
          "doc": "None",
          "signature": "(self)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "update_failed_login_budget_and_check_reset": {
          "doc": "None",
          "signature": "(self)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "user",
        "verbose_name_plural": "users",
        "abstract": false,
        "db_table": "security_user"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "logentry": {
          "type": "ManyToOneRel",
          "model": "LogEntry",
          "app": "admin",
          "related_name": null,
          "related_query_name": "logentry",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "ideavote": {
          "type": "ManyToOneRel",
          "model": "IdeaVote",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "ideavote",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "signuprequest": {
          "type": "OneToOneRel",
          "model": "SignUpRequest",
          "app": "security",
          "related_name": null,
          "related_query_name": "signuprequest",
          "many_to_many": false,
          "one_to_many": false,
          "one_to_one": true
        },
        "signinattempt": {
          "type": "ManyToOneRel",
          "model": "SignInAttempt",
          "app": "security",
          "related_name": null,
          "related_query_name": "signinattempt",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "person": {
          "type": "OneToOneRel",
          "model": "Person",
          "app": "talent",
          "related_name": null,
          "related_query_name": "person",
          "many_to_many": false,
          "one_to_many": false,
          "one_to_one": true
        },
        "social_auth": {
          "type": "ManyToOneRel",
          "model": "UserSocialAuth",
          "app": "social_django",
          "related_name": null,
          "related_query_name": "social_auth",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "User(id, password, last_login, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined, created_at, updated_at, remaining_budget_for_failed_logins, password_reset_required, is_test_user)",
      "app_label": "security"
    },
    "SignUpRequest": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "user": {
          "type": "OneToOneField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "User",
            "app": "security",
            "on_delete": "CASCADE"
          }
        },
        "device_hash": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "country": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "region_code": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "city": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "verification_code": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "successful": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "sign up request",
        "verbose_name_plural": "sign up requests",
        "abstract": false,
        "db_table": "security_signuprequest"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "SignUpRequest(id, created_at, updated_at, user, device_hash, country, region_code, city, verification_code, successful)",
      "app_label": "security"
    },
    "SignInAttempt": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "user": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "User",
            "app": "security",
            "on_delete": "CASCADE"
          }
        },
        "device_hash": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "country": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "region_code": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "city": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "successful": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "sign in attempt",
        "verbose_name_plural": "sign in attempts",
        "abstract": false,
        "db_table": "security_signinattempt"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "SignInAttempt(id, created_at, updated_at, user, device_hash, country, region_code, city, successful)",
      "app_label": "security"
    },
    "ProductRoleAssignment": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "person": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "product": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Product",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "role": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "Member": "Member",
            "Manager": "Manager",
            "Admin": "Admin"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_role_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.CharField: role>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "product role assignment",
        "verbose_name_plural": "product role assignments",
        "abstract": false,
        "db_table": "security_productroleassignment"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "Product-specific role assignments for users",
      "app_label": "security"
    },
    "OrganisationPersonRoleAssignment": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "person": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "organisation": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Organisation",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "role": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "Owner": "Owner",
            "Manager": "Manager",
            "Member": "Member"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_role_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.CharField: role>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [
          [
            "person",
            "organisation"
          ]
        ],
        "verbose_name": "organisation person role assignment",
        "verbose_name_plural": "organisation person role assignments",
        "abstract": false,
        "db_table": "security_organisationpersonroleassignment"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "Organisation-specific role assignments for users",
      "app_label": "security"
    },
    "BlacklistedUsernames": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "username": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "blacklisted usernames",
        "verbose_name_plural": "blacklisted usernamess",
        "abstract": false,
        "db_table": "black_listed_usernames"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "BlacklistedUsernames(id, username)",
      "app_label": "security"
    }
  },
  "talent": {
    "Person": {
      "fields": {
        "owned_products": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "created_by": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "updated_by": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "bounty_claimed_by": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "idea": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "bug": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "productcontributoragreementtemplate": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "contributor_agreement": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "product_roles": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "organisation_roles": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "skills": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "bountyclaim": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "challengecomment": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "bugcomment": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "ideacomment": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "capabilitycomment": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "bountydeliveryattempt": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "feedback_recipient": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "feedback_provider": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "cart": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "nominator": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "approver": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "productaccountcredit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "contributoraccount": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "full_name": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "preferred_name": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "user": {
          "type": "OneToOneField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "User",
            "app": "security",
            "on_delete": "CASCADE"
          }
        },
        "photo": {
          "type": "FileField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "headline": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "overview": {
          "type": "TextField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "location": {
          "type": "TextField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "send_me_bounties": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "current_position": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "twitter_link": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "linkedin_link": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "github_link": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "website_link": {
          "type": "CharField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "completed_profile": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "points": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "products": {
          "type": "ManyToManyField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "add_points": {
          "doc": "None",
          "signature": "(self, points)"
        },
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "delete_photo": {
          "doc": "None",
          "signature": "(self) -> None"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_absolute_url": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_display_points": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_full_name": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_initial_data": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_photo_url": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_points_privileges": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_points_status": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_products": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_short_name": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_username": {
          "doc": "None",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "toggle_bounties": {
          "doc": "None",
          "signature": "(self)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "person",
        "verbose_name_plural": "People",
        "abstract": false,
        "db_table": "talent_person"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "owned_products": {
          "type": "ManyToOneRel",
          "model": "Product",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "owned_products",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "created_by": {
          "type": "ManyToOneRel",
          "model": "Challenge",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "created_by",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "updated_by": {
          "type": "ManyToOneRel",
          "model": "Challenge",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "updated_by",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "bounty_claimed_by": {
          "type": "ManyToOneRel",
          "model": "Bounty",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "bounty_claimed_by",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "idea": {
          "type": "ManyToOneRel",
          "model": "Idea",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "idea",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "bug": {
          "type": "ManyToOneRel",
          "model": "Bug",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "bug",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "productcontributoragreementtemplate": {
          "type": "ManyToOneRel",
          "model": "ProductContributorAgreementTemplate",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "productcontributoragreementtemplate",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "contributor_agreement": {
          "type": "ManyToOneRel",
          "model": "ProductContributorAgreement",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "contributor_agreement",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "product_roles": {
          "type": "ManyToOneRel",
          "model": "ProductRoleAssignment",
          "app": "security",
          "related_name": null,
          "related_query_name": "product_roles",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "organisation_roles": {
          "type": "ManyToOneRel",
          "model": "OrganisationPersonRoleAssignment",
          "app": "security",
          "related_name": null,
          "related_query_name": "organisation_roles",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "skills": {
          "type": "ManyToOneRel",
          "model": "PersonSkill",
          "app": "talent",
          "related_name": null,
          "related_query_name": "skills",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "bountyclaim": {
          "type": "ManyToOneRel",
          "model": "BountyClaim",
          "app": "talent",
          "related_name": null,
          "related_query_name": "bountyclaim",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "challengecomment": {
          "type": "ManyToOneRel",
          "model": "ChallengeComment",
          "app": "talent",
          "related_name": null,
          "related_query_name": "challengecomment",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "bugcomment": {
          "type": "ManyToOneRel",
          "model": "BugComment",
          "app": "talent",
          "related_name": null,
          "related_query_name": "bugcomment",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "ideacomment": {
          "type": "ManyToOneRel",
          "model": "IdeaComment",
          "app": "talent",
          "related_name": null,
          "related_query_name": "ideacomment",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "capabilitycomment": {
          "type": "ManyToOneRel",
          "model": "CapabilityComment",
          "app": "talent",
          "related_name": null,
          "related_query_name": "capabilitycomment",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "bountydeliveryattempt": {
          "type": "ManyToOneRel",
          "model": "BountyDeliveryAttempt",
          "app": "talent",
          "related_name": null,
          "related_query_name": "bountydeliveryattempt",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "feedback_recipient": {
          "type": "ManyToOneRel",
          "model": "Feedback",
          "app": "talent",
          "related_name": null,
          "related_query_name": "feedback_recipient",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "feedback_provider": {
          "type": "ManyToOneRel",
          "model": "Feedback",
          "app": "talent",
          "related_name": null,
          "related_query_name": "feedback_provider",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "cart": {
          "type": "ManyToOneRel",
          "model": "Cart",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "cart",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "nominator": {
          "type": "ManyToOneRel",
          "model": "Grant",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "nominator",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "approver": {
          "type": "ManyToOneRel",
          "model": "Grant",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "approver",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "productaccountcredit": {
          "type": "ManyToOneRel",
          "model": "ProductAccountCredit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "productaccountcredit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "contributoraccount": {
          "type": "ManyToOneRel",
          "model": "ContributorAccount",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "contributoraccount",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "Person(id, created_at, updated_at, full_name, preferred_name, user, photo, headline, overview, location, send_me_bounties, current_position, twitter_link, linkedin_link, github_link, website_link, completed_profile, points)",
      "app_label": "talent"
    },
    "PersonSkill": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "person": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "skill": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Skill",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "expertise": {
          "type": "ManyToManyField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Expertise",
            "app": "talent",
            "through": "PersonSkill_expertise"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "person skill",
        "verbose_name_plural": "person skills",
        "abstract": false,
        "db_table": "talent_personskill"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "PersonSkill(id, person, skill)",
      "app_label": "talent"
    },
    "Skill": {
      "fields": {
        "bounty_skill": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "category_contributor_guide": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "personskill": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "children": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "skill_expertise": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "parent": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Skill",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "active": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "selectable": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "display_boost_factor": {
          "type": "PositiveSmallIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "name": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "ancestry": {
          "doc": "None",
          "signature": "(self)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_active_skill_list": {
          "doc": "None",
          "signature": "(active=True)"
        },
        "get_active_skills": {
          "doc": "None",
          "signature": "(active=True, parent=None)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "s_ancestry": {
          "doc": "None",
          "signature": "(obj, lineage)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "skill",
        "verbose_name_plural": "skills",
        "abstract": false,
        "db_table": "talent_skill"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "bounty_skill": {
          "type": "ManyToOneRel",
          "model": "Bounty",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "bounty_skill",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "category_contributor_guide": {
          "type": "ManyToOneRel",
          "model": "ContributorGuide",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "category_contributor_guide",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "personskill": {
          "type": "ManyToOneRel",
          "model": "PersonSkill",
          "app": "talent",
          "related_name": null,
          "related_query_name": "personskill",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "children": {
          "type": "ManyToOneRel",
          "model": "Skill",
          "app": "talent",
          "related_name": null,
          "related_query_name": "children",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "skill_expertise": {
          "type": "ManyToOneRel",
          "model": "Expertise",
          "app": "talent",
          "related_name": null,
          "related_query_name": "skill_expertise",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "Skill(id, parent, active, selectable, display_boost_factor, name)",
      "app_label": "talent"
    },
    "Expertise": {
      "fields": {
        "bounty_expertise": {
          "type": "ManyToManyField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "personskill": {
          "type": "ManyToManyField",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "expertise_children": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "parent": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Expertise",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "skill": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Skill",
            "app": "talent",
            "on_delete": "SET_NULL"
          }
        },
        "selectable": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "name": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "fa_icon": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "ancestry": {
          "doc": "None",
          "signature": "(self)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_all_expertise": {
          "doc": "None",
          "signature": "(parent=None)"
        },
        "get_all_expertise_list": {
          "doc": "None",
          "signature": "()"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_skill_expertise": {
          "doc": "None",
          "signature": "(skill)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "s_ancestry": {
          "doc": "None",
          "signature": "(obj, lineage)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "expertise",
        "verbose_name_plural": "expertises",
        "abstract": false,
        "db_table": "talent_expertise"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "bounty_expertise": {
          "type": "ManyToManyRel",
          "model": "Bounty",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "bounty_expertise",
          "many_to_many": true,
          "one_to_many": false,
          "one_to_one": false
        },
        "personskill": {
          "type": "ManyToManyRel",
          "model": "PersonSkill",
          "app": "talent",
          "related_name": null,
          "related_query_name": "personskill",
          "many_to_many": true,
          "one_to_many": false,
          "one_to_one": false
        },
        "expertise_children": {
          "type": "ManyToOneRel",
          "model": "Expertise",
          "app": "talent",
          "related_name": null,
          "related_query_name": "expertise_children",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "Expertise(id, parent, skill, selectable, name, fa_icon)",
      "app_label": "talent"
    },
    "BountyClaim": {
      "fields": {
        "delivery_attempt": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "productaccountreservation": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "productaccountdebit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "contributoraccountcredit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "bounty": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Bounty",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "person": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "expected_finish_date": {
          "type": "DateField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "status": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "Requested": "Requested",
            "Cancelled": "Cancelled",
            "Rejected": "Rejected",
            "Granted": "Granted",
            "Contributed": "Contributed",
            "Completed": "Completed",
            "Failed": "Failed"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_challenge_detail_url": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_next_by_expected_finish_date": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateField: expected_finish_date>, is_next=True, **kwargs)"
        },
        "get_previous_by_expected_finish_date": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateField: expected_finish_date>, is_next=False, **kwargs)"
        },
        "get_product_detail_url": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_status_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.CharField: status>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [
          "-created_at"
        ],
        "unique_together": [
          [
            "bounty",
            "person"
          ]
        ],
        "verbose_name": "bounty claim",
        "verbose_name_plural": "bounty claims",
        "abstract": false,
        "db_table": "talent_bountyclaim"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "delivery_attempt": {
          "type": "ManyToOneRel",
          "model": "BountyDeliveryAttempt",
          "app": "talent",
          "related_name": null,
          "related_query_name": "delivery_attempt",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "productaccountreservation": {
          "type": "ManyToOneRel",
          "model": "ProductAccountReservation",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "productaccountreservation",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "productaccountdebit": {
          "type": "ManyToOneRel",
          "model": "ProductAccountDebit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "productaccountdebit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "contributoraccountcredit": {
          "type": "ManyToOneRel",
          "model": "ContributorAccountCredit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "contributoraccountcredit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "BountyClaim(id, created_at, updated_at, uuid, bounty, person, expected_finish_date, status)",
      "app_label": "talent"
    },
    "ChallengeComment": {
      "fields": {
        "challenge": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "path": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "depth": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "numchild": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "person": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "text": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "add_child": {
          "doc": "Adds a child to the node.\n\nThis method saves the node in database. The object is populated as if via:\n\n```\nobj = self.__class__(**kwargs)\n```\n\n:raise PathOverflow: when no more child nodes can be added",
          "signature": "(self, **kwargs)"
        },
        "add_sibling": {
          "doc": "Adds a new node as a sibling to the current node object.\n\nThis method saves the node in database. The object is populated as if via:\n\n```\nobj = self.__class__(**kwargs)\n```\n\n:raise PathOverflow: when the library can't make room for the\n   node's new position",
          "signature": "(self, pos=None, **kwargs)"
        },
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "Removes a node and all it's descendants.",
          "signature": "(self, *args, **kwargs)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_ancestors": {
          "doc": ":returns: A queryset containing the current node object's ancestors,\n    starting by the root node and descending to the parent.",
          "signature": "(self)"
        },
        "get_children": {
          "doc": ":returns: A queryset of all the node's children",
          "signature": "(self)"
        },
        "get_children_count": {
          "doc": ":returns: The number the node's children, calculated in the most\nefficient possible way.",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_depth": {
          "doc": ":returns: the depth (level) of the node",
          "signature": "(self)"
        },
        "get_descendant_count": {
          "doc": ":returns: the number of descendants of a node.",
          "signature": "(self)"
        },
        "get_descendants": {
          "doc": ":returns: A queryset of all the node's descendants as DFS, doesn't\n    include the node itself",
          "signature": "(self)"
        },
        "get_first_child": {
          "doc": ":returns:\n\n    The leftmost node's child, or None if it has no children.",
          "signature": "(self)"
        },
        "get_first_sibling": {
          "doc": ":returns:\n\n    The leftmost node's sibling, can return the node itself if\n    it was the leftmost sibling.",
          "signature": "(self)"
        },
        "get_last_child": {
          "doc": ":returns:\n\n    The rightmost node's child, or None if it has no children.",
          "signature": "(self)"
        },
        "get_last_sibling": {
          "doc": ":returns:\n\n    The rightmost node's sibling, can return the node itself if\n    it was the rightmost sibling.",
          "signature": "(self)"
        },
        "get_next_sibling": {
          "doc": ":returns: The next node's sibling, or None if it was the rightmost\n    sibling.",
          "signature": "(self)"
        },
        "get_parent": {
          "doc": ":returns: the parent node of the current node object.\n    Caches the result in the object itself to help in loops.",
          "signature": "(self, update=False)"
        },
        "get_prev_sibling": {
          "doc": ":returns: The previous node's sibling, or None if it was the leftmost\n    sibling.",
          "signature": "(self)"
        },
        "get_root": {
          "doc": ":returns: the root node for the current node object.",
          "signature": "(self)"
        },
        "get_siblings": {
          "doc": ":returns: A queryset of all the node's siblings, including the node\n    itself.",
          "signature": "(self)"
        },
        "get_sorted_pos_queryset": {
          "doc": ":returns:\n\n    A queryset of the nodes that must be moved to the right.\n    Called only for Node models with :attr:`node_order_by`\n\nThis function is based on _insertion_target_filters from django-mptt\n(BSD licensed) by Jonathan Buchanan:\nhttps://github.com/django-mptt/django-mptt/blob/0.3.0/mptt/signals.py",
          "signature": "(self, siblings, newobj)"
        },
        "is_child_of": {
          "doc": ":returns: ``True`` is the node if a child of another node given as an\n    argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "is_descendant_of": {
          "doc": ":returns: ``True`` if the node is a descendant of another node given\n    as an argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "is_leaf": {
          "doc": ":returns: True if the node is a leaf node (else, returns False)",
          "signature": "(self)"
        },
        "is_root": {
          "doc": ":returns: True if the node is a root node (else, returns False)",
          "signature": "(self)"
        },
        "is_sibling_of": {
          "doc": ":returns: ``True`` if the node is a sibling of another node given as an\n    argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "move": {
          "doc": "Moves the current node and all it's descendants to a new position\nrelative to another node.\n\n:raise PathOverflow: when the library can't make room for the\n   node's new position",
          "signature": "(self, target, pos=None)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "challenge comment",
        "verbose_name_plural": "challenge comments",
        "abstract": false,
        "db_table": "talent_challengecomment"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "challenge": {
          "type": "ManyToOneRel",
          "model": "Challenge",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "challenge",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "ChallengeComment(id, path, depth, numchild, person, text)",
      "app_label": "talent"
    },
    "BugComment": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "path": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "depth": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "numchild": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "person": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "text": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "add_child": {
          "doc": "Adds a child to the node.\n\nThis method saves the node in database. The object is populated as if via:\n\n```\nobj = self.__class__(**kwargs)\n```\n\n:raise PathOverflow: when no more child nodes can be added",
          "signature": "(self, **kwargs)"
        },
        "add_sibling": {
          "doc": "Adds a new node as a sibling to the current node object.\n\nThis method saves the node in database. The object is populated as if via:\n\n```\nobj = self.__class__(**kwargs)\n```\n\n:raise PathOverflow: when the library can't make room for the\n   node's new position",
          "signature": "(self, pos=None, **kwargs)"
        },
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "Removes a node and all it's descendants.",
          "signature": "(self, *args, **kwargs)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_ancestors": {
          "doc": ":returns: A queryset containing the current node object's ancestors,\n    starting by the root node and descending to the parent.",
          "signature": "(self)"
        },
        "get_children": {
          "doc": ":returns: A queryset of all the node's children",
          "signature": "(self)"
        },
        "get_children_count": {
          "doc": ":returns: The number the node's children, calculated in the most\nefficient possible way.",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_depth": {
          "doc": ":returns: the depth (level) of the node",
          "signature": "(self)"
        },
        "get_descendant_count": {
          "doc": ":returns: the number of descendants of a node.",
          "signature": "(self)"
        },
        "get_descendants": {
          "doc": ":returns: A queryset of all the node's descendants as DFS, doesn't\n    include the node itself",
          "signature": "(self)"
        },
        "get_first_child": {
          "doc": ":returns:\n\n    The leftmost node's child, or None if it has no children.",
          "signature": "(self)"
        },
        "get_first_sibling": {
          "doc": ":returns:\n\n    The leftmost node's sibling, can return the node itself if\n    it was the leftmost sibling.",
          "signature": "(self)"
        },
        "get_last_child": {
          "doc": ":returns:\n\n    The rightmost node's child, or None if it has no children.",
          "signature": "(self)"
        },
        "get_last_sibling": {
          "doc": ":returns:\n\n    The rightmost node's sibling, can return the node itself if\n    it was the rightmost sibling.",
          "signature": "(self)"
        },
        "get_next_sibling": {
          "doc": ":returns: The next node's sibling, or None if it was the rightmost\n    sibling.",
          "signature": "(self)"
        },
        "get_parent": {
          "doc": ":returns: the parent node of the current node object.\n    Caches the result in the object itself to help in loops.",
          "signature": "(self, update=False)"
        },
        "get_prev_sibling": {
          "doc": ":returns: The previous node's sibling, or None if it was the leftmost\n    sibling.",
          "signature": "(self)"
        },
        "get_root": {
          "doc": ":returns: the root node for the current node object.",
          "signature": "(self)"
        },
        "get_siblings": {
          "doc": ":returns: A queryset of all the node's siblings, including the node\n    itself.",
          "signature": "(self)"
        },
        "get_sorted_pos_queryset": {
          "doc": ":returns:\n\n    A queryset of the nodes that must be moved to the right.\n    Called only for Node models with :attr:`node_order_by`\n\nThis function is based on _insertion_target_filters from django-mptt\n(BSD licensed) by Jonathan Buchanan:\nhttps://github.com/django-mptt/django-mptt/blob/0.3.0/mptt/signals.py",
          "signature": "(self, siblings, newobj)"
        },
        "is_child_of": {
          "doc": ":returns: ``True`` is the node if a child of another node given as an\n    argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "is_descendant_of": {
          "doc": ":returns: ``True`` if the node is a descendant of another node given\n    as an argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "is_leaf": {
          "doc": ":returns: True if the node is a leaf node (else, returns False)",
          "signature": "(self)"
        },
        "is_root": {
          "doc": ":returns: True if the node is a root node (else, returns False)",
          "signature": "(self)"
        },
        "is_sibling_of": {
          "doc": ":returns: ``True`` if the node is a sibling of another node given as an\n    argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "move": {
          "doc": "Moves the current node and all it's descendants to a new position\nrelative to another node.\n\n:raise PathOverflow: when the library can't make room for the\n   node's new position",
          "signature": "(self, target, pos=None)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "bug comment",
        "verbose_name_plural": "bug comments",
        "abstract": false,
        "db_table": "talent_bugcomment"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "BugComment(id, path, depth, numchild, person, text)",
      "app_label": "talent"
    },
    "IdeaComment": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "path": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "depth": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "numchild": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "person": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "text": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "add_child": {
          "doc": "Adds a child to the node.\n\nThis method saves the node in database. The object is populated as if via:\n\n```\nobj = self.__class__(**kwargs)\n```\n\n:raise PathOverflow: when no more child nodes can be added",
          "signature": "(self, **kwargs)"
        },
        "add_sibling": {
          "doc": "Adds a new node as a sibling to the current node object.\n\nThis method saves the node in database. The object is populated as if via:\n\n```\nobj = self.__class__(**kwargs)\n```\n\n:raise PathOverflow: when the library can't make room for the\n   node's new position",
          "signature": "(self, pos=None, **kwargs)"
        },
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "Removes a node and all it's descendants.",
          "signature": "(self, *args, **kwargs)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_ancestors": {
          "doc": ":returns: A queryset containing the current node object's ancestors,\n    starting by the root node and descending to the parent.",
          "signature": "(self)"
        },
        "get_children": {
          "doc": ":returns: A queryset of all the node's children",
          "signature": "(self)"
        },
        "get_children_count": {
          "doc": ":returns: The number the node's children, calculated in the most\nefficient possible way.",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_depth": {
          "doc": ":returns: the depth (level) of the node",
          "signature": "(self)"
        },
        "get_descendant_count": {
          "doc": ":returns: the number of descendants of a node.",
          "signature": "(self)"
        },
        "get_descendants": {
          "doc": ":returns: A queryset of all the node's descendants as DFS, doesn't\n    include the node itself",
          "signature": "(self)"
        },
        "get_first_child": {
          "doc": ":returns:\n\n    The leftmost node's child, or None if it has no children.",
          "signature": "(self)"
        },
        "get_first_sibling": {
          "doc": ":returns:\n\n    The leftmost node's sibling, can return the node itself if\n    it was the leftmost sibling.",
          "signature": "(self)"
        },
        "get_last_child": {
          "doc": ":returns:\n\n    The rightmost node's child, or None if it has no children.",
          "signature": "(self)"
        },
        "get_last_sibling": {
          "doc": ":returns:\n\n    The rightmost node's sibling, can return the node itself if\n    it was the rightmost sibling.",
          "signature": "(self)"
        },
        "get_next_sibling": {
          "doc": ":returns: The next node's sibling, or None if it was the rightmost\n    sibling.",
          "signature": "(self)"
        },
        "get_parent": {
          "doc": ":returns: the parent node of the current node object.\n    Caches the result in the object itself to help in loops.",
          "signature": "(self, update=False)"
        },
        "get_prev_sibling": {
          "doc": ":returns: The previous node's sibling, or None if it was the leftmost\n    sibling.",
          "signature": "(self)"
        },
        "get_root": {
          "doc": ":returns: the root node for the current node object.",
          "signature": "(self)"
        },
        "get_siblings": {
          "doc": ":returns: A queryset of all the node's siblings, including the node\n    itself.",
          "signature": "(self)"
        },
        "get_sorted_pos_queryset": {
          "doc": ":returns:\n\n    A queryset of the nodes that must be moved to the right.\n    Called only for Node models with :attr:`node_order_by`\n\nThis function is based on _insertion_target_filters from django-mptt\n(BSD licensed) by Jonathan Buchanan:\nhttps://github.com/django-mptt/django-mptt/blob/0.3.0/mptt/signals.py",
          "signature": "(self, siblings, newobj)"
        },
        "is_child_of": {
          "doc": ":returns: ``True`` is the node if a child of another node given as an\n    argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "is_descendant_of": {
          "doc": ":returns: ``True`` if the node is a descendant of another node given\n    as an argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "is_leaf": {
          "doc": ":returns: True if the node is a leaf node (else, returns False)",
          "signature": "(self)"
        },
        "is_root": {
          "doc": ":returns: True if the node is a root node (else, returns False)",
          "signature": "(self)"
        },
        "is_sibling_of": {
          "doc": ":returns: ``True`` if the node is a sibling of another node given as an\n    argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "move": {
          "doc": "Moves the current node and all it's descendants to a new position\nrelative to another node.\n\n:raise PathOverflow: when the library can't make room for the\n   node's new position",
          "signature": "(self, target, pos=None)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "idea comment",
        "verbose_name_plural": "idea comments",
        "abstract": false,
        "db_table": "talent_ideacomment"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "IdeaComment(id, path, depth, numchild, person, text)",
      "app_label": "talent"
    },
    "CapabilityComment": {
      "fields": {
        "productarea": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "path": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "depth": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "numchild": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "person": {
          "type": "ForeignKey",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "text": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "add_child": {
          "doc": "Adds a child to the node.\n\nThis method saves the node in database. The object is populated as if via:\n\n```\nobj = self.__class__(**kwargs)\n```\n\n:raise PathOverflow: when no more child nodes can be added",
          "signature": "(self, **kwargs)"
        },
        "add_sibling": {
          "doc": "Adds a new node as a sibling to the current node object.\n\nThis method saves the node in database. The object is populated as if via:\n\n```\nobj = self.__class__(**kwargs)\n```\n\n:raise PathOverflow: when the library can't make room for the\n   node's new position",
          "signature": "(self, pos=None, **kwargs)"
        },
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "Removes a node and all it's descendants.",
          "signature": "(self, *args, **kwargs)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_ancestors": {
          "doc": ":returns: A queryset containing the current node object's ancestors,\n    starting by the root node and descending to the parent.",
          "signature": "(self)"
        },
        "get_children": {
          "doc": ":returns: A queryset of all the node's children",
          "signature": "(self)"
        },
        "get_children_count": {
          "doc": ":returns: The number the node's children, calculated in the most\nefficient possible way.",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_depth": {
          "doc": ":returns: the depth (level) of the node",
          "signature": "(self)"
        },
        "get_descendant_count": {
          "doc": ":returns: the number of descendants of a node.",
          "signature": "(self)"
        },
        "get_descendants": {
          "doc": ":returns: A queryset of all the node's descendants as DFS, doesn't\n    include the node itself",
          "signature": "(self)"
        },
        "get_first_child": {
          "doc": ":returns:\n\n    The leftmost node's child, or None if it has no children.",
          "signature": "(self)"
        },
        "get_first_sibling": {
          "doc": ":returns:\n\n    The leftmost node's sibling, can return the node itself if\n    it was the leftmost sibling.",
          "signature": "(self)"
        },
        "get_last_child": {
          "doc": ":returns:\n\n    The rightmost node's child, or None if it has no children.",
          "signature": "(self)"
        },
        "get_last_sibling": {
          "doc": ":returns:\n\n    The rightmost node's sibling, can return the node itself if\n    it was the rightmost sibling.",
          "signature": "(self)"
        },
        "get_next_sibling": {
          "doc": ":returns: The next node's sibling, or None if it was the rightmost\n    sibling.",
          "signature": "(self)"
        },
        "get_parent": {
          "doc": ":returns: the parent node of the current node object.\n    Caches the result in the object itself to help in loops.",
          "signature": "(self, update=False)"
        },
        "get_prev_sibling": {
          "doc": ":returns: The previous node's sibling, or None if it was the leftmost\n    sibling.",
          "signature": "(self)"
        },
        "get_root": {
          "doc": ":returns: the root node for the current node object.",
          "signature": "(self)"
        },
        "get_siblings": {
          "doc": ":returns: A queryset of all the node's siblings, including the node\n    itself.",
          "signature": "(self)"
        },
        "get_sorted_pos_queryset": {
          "doc": ":returns:\n\n    A queryset of the nodes that must be moved to the right.\n    Called only for Node models with :attr:`node_order_by`\n\nThis function is based on _insertion_target_filters from django-mptt\n(BSD licensed) by Jonathan Buchanan:\nhttps://github.com/django-mptt/django-mptt/blob/0.3.0/mptt/signals.py",
          "signature": "(self, siblings, newobj)"
        },
        "is_child_of": {
          "doc": ":returns: ``True`` is the node if a child of another node given as an\n    argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "is_descendant_of": {
          "doc": ":returns: ``True`` if the node is a descendant of another node given\n    as an argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "is_leaf": {
          "doc": ":returns: True if the node is a leaf node (else, returns False)",
          "signature": "(self)"
        },
        "is_root": {
          "doc": ":returns: True if the node is a root node (else, returns False)",
          "signature": "(self)"
        },
        "is_sibling_of": {
          "doc": ":returns: ``True`` if the node is a sibling of another node given as an\n    argument, else, returns ``False``",
          "signature": "(self, node)"
        },
        "move": {
          "doc": "Moves the current node and all it's descendants to a new position\nrelative to another node.\n\n:raise PathOverflow: when the library can't make room for the\n   node's new position",
          "signature": "(self, target, pos=None)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "capability comment",
        "verbose_name_plural": "capability comments",
        "abstract": false,
        "db_table": "talent_capabilitycomment"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "productarea": {
          "type": "ManyToOneRel",
          "model": "ProductArea",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "productarea",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "CapabilityComment(id, path, depth, numchild, person, text)",
      "app_label": "talent"
    },
    "BountyDeliveryAttempt": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "kind": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "New": "New",
            "Approved": "Approved",
            "Rejected": "Rejected"
          }
        },
        "bounty_claim": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "BountyClaim",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "person": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "is_canceled": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "delivery_message": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "attachments": {
          "type": "ManyToManyField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "FileAttachment",
            "app": "product_management",
            "through": "BountyDeliveryAttempt_attachments"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_absolute_url": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_kind_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.CharField: kind>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [
          "-created_at"
        ],
        "unique_together": [],
        "verbose_name": "bounty delivery attempt",
        "verbose_name_plural": "bounty delivery attempts",
        "abstract": false,
        "db_table": "talent_bountydeliveryattempt"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "BountyDeliveryAttempt(id, created_at, updated_at, kind, bounty_claim, person, is_canceled, delivery_message)",
      "app_label": "talent"
    },
    "Feedback": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "recipient": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "provider": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "message": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "stars": {
          "type": "PositiveSmallIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, *args, **kwargs)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "feedback",
        "verbose_name_plural": "feedbacks",
        "abstract": false,
        "db_table": "talent_feedback"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "Feedback(id, recipient, provider, message, stars)",
      "app_label": "talent"
    }
  },
  "engagement": {
    "EmailNotification": {
      "fields": {
        "event_type": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "0": "Bounty Claimed",
            "1": "Challenge Comment",
            "2": "Submission Approved",
            "3": "Submission Rejected",
            "4": "Bug Rejected",
            "5": "Idea Rejected",
            "6": "Bug Created",
            "7": "Idea Created",
            "8": "Bug Created For Members",
            "9": "Idea Created For Members",
            "10": "Task Status Changed",
            "11": "Bounty In Review",
            "12": "Generic Comment",
            "13": "Bounty Submission Made",
            "14": "Task Ready To Review",
            "15": "Task Delivery Attempt Created",
            "16": "Contributor Abandoned Bounty",
            "17": "Submission Revision Requested"
          }
        },
        "permitted_params": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "title": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "template": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_event_type_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: event_type>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "email notification",
        "verbose_name_plural": "email notifications",
        "abstract": false,
        "db_table": "engagement_emailnotification"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "EmailNotification(event_type, permitted_params, title, template)",
      "app_label": "engagement"
    }
  },
  "commerce": {
    "Organisation": {
      "fields": {
        "owned_products": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "person_role_assignments": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "organisationaccount": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "username": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "name": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "photo": {
          "type": "FileField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "products": {
          "type": "ManyToManyField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_username": {
          "doc": "None",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "organisation",
        "verbose_name_plural": "Organisations",
        "abstract": false,
        "db_table": "commerce_organisation"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "owned_products": {
          "type": "ManyToOneRel",
          "model": "Product",
          "app": "product_management",
          "related_name": null,
          "related_query_name": "owned_products",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "person_role_assignments": {
          "type": "ManyToOneRel",
          "model": "OrganisationPersonRoleAssignment",
          "app": "security",
          "related_name": null,
          "related_query_name": "person_role_assignments",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "organisationaccount": {
          "type": "ManyToOneRel",
          "model": "OrganisationAccount",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "organisationaccount",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "Organisation(id, created_at, updated_at, username, name, photo)",
      "app_label": "commerce"
    },
    "OrganisationAccountCredit": {
      "fields": {
        "grant": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "salesorder": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "organisation_account": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "OrganisationAccount",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "number_of_points": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "type_of_points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NONLIQUID",
            "2": "LIQUID"
          }
        },
        "credit_reason": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "GRANT",
            "2": "SALE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_credit_reason_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: credit_reason>)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_type_of_points_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: type_of_points>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "organisation account credit",
        "verbose_name_plural": "organisation account credits",
        "abstract": false,
        "db_table": "commerce_organisationaccountcredit"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "grant": {
          "type": "ManyToOneRel",
          "model": "Grant",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "grant",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "salesorder": {
          "type": "ManyToOneRel",
          "model": "SalesOrder",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "salesorder",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "OrganisationAccountCredit(id, created_at, updated_at, uuid, organisation_account, number_of_points, type_of_points, credit_reason)",
      "app_label": "commerce"
    },
    "OrganisationAccount": {
      "fields": {
        "organisationaccountcredit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "cart": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "grant": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "salesorder": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "organisationaccountdebit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "organisation": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Organisation",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "liquid_points_balance": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "nonliquid_points_balance": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "organisation account",
        "verbose_name_plural": "organisation accounts",
        "abstract": false,
        "db_table": "commerce_organisationaccount"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "organisationaccountcredit": {
          "type": "ManyToOneRel",
          "model": "OrganisationAccountCredit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "organisationaccountcredit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "cart": {
          "type": "ManyToOneRel",
          "model": "Cart",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "cart",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "grant": {
          "type": "ManyToOneRel",
          "model": "Grant",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "grant",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "salesorder": {
          "type": "ManyToOneRel",
          "model": "SalesOrder",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "salesorder",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "organisationaccountdebit": {
          "type": "ManyToOneRel",
          "model": "OrganisationAccountDebit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "organisationaccountdebit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "OrganisationAccount(id, organisation, liquid_points_balance, nonliquid_points_balance)",
      "app_label": "commerce"
    },
    "Cart": {
      "fields": {
        "salesorder": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "organisation_account": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "OrganisationAccount",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "creator": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "number_of_points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "currency_of_payment": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "USD",
            "2": "EUR",
            "3": "GBP"
          }
        },
        "price_per_point_in_cents": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "subtotal_in_cents": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "sales_tax_in_cents": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "total_payable_in_cents": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "payment_type": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NONE",
            "2": "ONLINE",
            "3": "OFFLINE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_currency_of_payment_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: currency_of_payment>)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_payment_type_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: payment_type>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "cart",
        "verbose_name_plural": "carts",
        "abstract": false,
        "db_table": "commerce_cart"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "salesorder": {
          "type": "ManyToOneRel",
          "model": "SalesOrder",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "salesorder",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "Cart(id, created_at, updated_at, uuid, organisation_account, creator, number_of_points, currency_of_payment, price_per_point_in_cents, subtotal_in_cents, sales_tax_in_cents, total_payable_in_cents, payment_type)",
      "app_label": "commerce"
    },
    "Grant": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "organisation_account": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "OrganisationAccount",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "nominating_bee_keeper": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "approving_bee_keeper": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "description": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "number_of_points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "status": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NEW",
            "2": "COMPLETE",
            "3": "CANCELLED"
          }
        },
        "organisation_account_credit": {
          "type": "ForeignKey",
          "null": true,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "OrganisationAccountCredit",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_status_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: status>)"
        },
        "mark_points_as_granted": {
          "doc": "None",
          "signature": "(self, credit)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "grant",
        "verbose_name_plural": "grants",
        "abstract": false,
        "db_table": "commerce_grant"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "Grant(id, organisation_account, nominating_bee_keeper, approving_bee_keeper, description, number_of_points, status, organisation_account_credit)",
      "app_label": "commerce"
    },
    "SalesOrder": {
      "fields": {
        "inboundpayment": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "organisation_account": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "OrganisationAccount",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "organisation_account_credit": {
          "type": "ForeignKey",
          "null": true,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "OrganisationAccountCredit",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "cart": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Cart",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "number_of_points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "currency_of_payment": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "USD",
            "2": "EUR",
            "3": "GBP"
          }
        },
        "price_per_point_in_cents": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "subtotal_in_cents": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "sales_tax_in_cents": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "total_payable_in_cents": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "payment_type": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NONE",
            "2": "ONLINE",
            "3": "OFFLINE"
          }
        },
        "payment_status": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "PENDING",
            "2": "PAID",
            "3": "CANCELLED",
            "4": "REFUNDED"
          }
        },
        "process_status": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NEW",
            "2": "COMPLETE",
            "3": "CANCELLED"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_currency_of_payment_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: currency_of_payment>)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_payment_status_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: payment_status>)"
        },
        "get_payment_type_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: payment_type>)"
        },
        "get_process_status_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: process_status>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "sales order",
        "verbose_name_plural": "sales orders",
        "abstract": false,
        "db_table": "commerce_salesorder"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "inboundpayment": {
          "type": "ManyToOneRel",
          "model": "InboundPayment",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "inboundpayment",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "SalesOrder(id, created_at, updated_at, uuid, organisation_account, organisation_account_credit, cart, number_of_points, currency_of_payment, price_per_point_in_cents, subtotal_in_cents, sales_tax_in_cents, total_payable_in_cents, payment_type, payment_status, process_status)",
      "app_label": "commerce"
    },
    "InboundPayment": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "sales_order": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "SalesOrder",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "payment_type": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NONE",
            "2": "ONLINE",
            "3": "OFFLINE"
          }
        },
        "currency_of_payment": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "USD",
            "2": "EUR",
            "3": "GBP"
          }
        },
        "amount_paid_in_cents": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "transaction_detail": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_currency_of_payment_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: currency_of_payment>)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_payment_type_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: payment_type>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "inbound payment",
        "verbose_name_plural": "inbound payments",
        "abstract": false,
        "db_table": "commerce_inboundpayment"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "InboundPayment(id, created_at, updated_at, uuid, sales_order, payment_type, currency_of_payment, amount_paid_in_cents, transaction_detail)",
      "app_label": "commerce"
    },
    "OrganisationAccountDebit": {
      "fields": {
        "productaccountcredit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "organisation_account": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "OrganisationAccount",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "type_of_points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NONLIQUID",
            "2": "LIQUID"
          }
        },
        "debit_reason": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "TRANSFER",
            "2": "EXPIRY"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_debit_reason_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: debit_reason>)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_type_of_points_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: type_of_points>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "organisation account debit",
        "verbose_name_plural": "organisation account debits",
        "abstract": false,
        "db_table": "commerce_organisationaccountdebit"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "productaccountcredit": {
          "type": "ManyToOneRel",
          "model": "ProductAccountCredit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "productaccountcredit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "OrganisationAccountDebit(id, created_at, updated_at, uuid, organisation_account, type_of_points, debit_reason)",
      "app_label": "commerce"
    },
    "ProductAccount": {
      "fields": {
        "productaccountcredit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "product": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Product",
            "app": "product_management",
            "on_delete": "CASCADE"
          }
        },
        "liquid_points_balance": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "nonliquid_points_balance": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "product account",
        "verbose_name_plural": "product accounts",
        "abstract": false,
        "db_table": "commerce_productaccount"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "productaccountcredit": {
          "type": "ManyToOneRel",
          "model": "ProductAccountCredit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "productaccountcredit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "ProductAccount(id, product, liquid_points_balance, nonliquid_points_balance)",
      "app_label": "commerce"
    },
    "ProductAccountCredit": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "organisation_account_debit": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "OrganisationAccountDebit",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "product_account": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ProductAccount",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "number_of_points": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "type_of_points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NONLIQUID",
            "2": "LIQUID"
          }
        },
        "actioned_by": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_type_of_points_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: type_of_points>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "product account credit",
        "verbose_name_plural": "product account credits",
        "abstract": false,
        "db_table": "commerce_productaccountcredit"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "ProductAccountCredit(id, created_at, updated_at, uuid, organisation_account_debit, product_account, number_of_points, type_of_points, actioned_by)",
      "app_label": "commerce"
    },
    "ProductAccountReservation": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "bounty_claim": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "BountyClaim",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "number_of_points": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "type_of_points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NONLIQUID",
            "2": "LIQUID"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_type_of_points_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: type_of_points>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "product account reservation",
        "verbose_name_plural": "product account reservations",
        "abstract": false,
        "db_table": "commerce_productaccountreservation"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "ProductAccountReservation(id, created_at, updated_at, uuid, bounty_claim, number_of_points, type_of_points)",
      "app_label": "commerce"
    },
    "ProductAccountDebit": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "bounty_claim": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "BountyClaim",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "number_of_points": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "type_of_points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NONLIQUID",
            "2": "LIQUID"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_type_of_points_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: type_of_points>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "product account debit",
        "verbose_name_plural": "product account debits",
        "abstract": false,
        "db_table": "commerce_productaccountdebit"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "ProductAccountDebit(id, created_at, updated_at, uuid, bounty_claim, number_of_points, type_of_points)",
      "app_label": "commerce"
    },
    "ContributorAccount": {
      "fields": {
        "paymentorder": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "contributorreward": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "contributoraccountcredit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "contributoraccountdebit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "owner": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "Person",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "community_status": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "DRONE",
            "2": "HONEY_BEE",
            "3": "TRUSTED_BEE",
            "4": "QUEEN_BEE",
            "5": "BEE_KEEPER"
          }
        },
        "liquid_points_balance": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "nonliquid_points_balance": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_community_status_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: community_status>)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "contributor account",
        "verbose_name_plural": "contributor accounts",
        "abstract": false,
        "db_table": "commerce_contributoraccount"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "paymentorder": {
          "type": "ManyToOneRel",
          "model": "PaymentOrder",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "paymentorder",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "contributorreward": {
          "type": "ManyToOneRel",
          "model": "ContributorReward",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "contributorreward",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "contributoraccountcredit": {
          "type": "ManyToOneRel",
          "model": "ContributorAccountCredit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "contributoraccountcredit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "contributoraccountdebit": {
          "type": "ManyToOneRel",
          "model": "ContributorAccountDebit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "contributoraccountdebit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "ContributorAccount(id, owner, community_status, liquid_points_balance, nonliquid_points_balance)",
      "app_label": "commerce"
    },
    "PaymentOrder": {
      "fields": {
        "outboundpayment": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "contributoraccountcredit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "contributoraccountdebit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "contributor_account": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ContributorAccount",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "currency_of_payment": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "USD",
            "2": "EUR",
            "3": "GBP"
          }
        },
        "subtotal_in_cents": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "sales_tax_in_cents": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "total_payable_in_cents": {
          "type": "PositiveBigIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "payment_type": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "PARTNER",
            "2": "BANK TRANSFER"
          }
        },
        "status": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NEW",
            "2": "COMPLETE",
            "3": "CANCELLED"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_currency_of_payment_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: currency_of_payment>)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_payment_type_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: payment_type>)"
        },
        "get_status_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: status>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "payment order",
        "verbose_name_plural": "payment orders",
        "abstract": false,
        "db_table": "commerce_paymentorder"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "outboundpayment": {
          "type": "ManyToOneRel",
          "model": "OutboundPayment",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "outboundpayment",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "contributoraccountcredit": {
          "type": "ManyToOneRel",
          "model": "ContributorAccountCredit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "contributoraccountcredit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        },
        "contributoraccountdebit": {
          "type": "ManyToOneRel",
          "model": "ContributorAccountDebit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "contributoraccountdebit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "PaymentOrder(id, created_at, updated_at, uuid, contributor_account, currency_of_payment, subtotal_in_cents, sales_tax_in_cents, total_payable_in_cents, payment_type, status)",
      "app_label": "commerce"
    },
    "OutboundPayment": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "payment_order": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "PaymentOrder",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "details": {
          "type": "TextField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "outbound payment",
        "verbose_name_plural": "outbound payments",
        "abstract": false,
        "db_table": "commerce_outboundpayment"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "OutboundPayment(id, created_at, updated_at, uuid, payment_order, details)",
      "app_label": "commerce"
    },
    "ContributorReward": {
      "fields": {
        "contributoraccountcredit": {
          "type": "ForeignKey",
          "null": true,
          "blank": null,
          "help_text": "",
          "choices": null
        },
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "contributor_account": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ContributorAccount",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "action": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "INVITED FRIENDS",
            "2": "VERIFIED IDENTITY"
          }
        },
        "points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_action_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: action>)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "contributor reward",
        "verbose_name_plural": "contributor rewards",
        "abstract": false,
        "db_table": "commerce_contributorreward"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {
        "contributoraccountcredit": {
          "type": "ManyToOneRel",
          "model": "ContributorAccountCredit",
          "app": "commerce",
          "related_name": null,
          "related_query_name": "contributoraccountcredit",
          "many_to_many": false,
          "one_to_many": true,
          "one_to_one": false
        }
      },
      "doc": "ContributorReward(id, created_at, updated_at, uuid, contributor_account, action, points)",
      "app_label": "commerce"
    },
    "ContributorAccountCredit": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "reason": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "BOUNTY",
            "2": "LIQUIDATION",
            "3": "REWARD"
          }
        },
        "bounty_claim": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "BountyClaim",
            "app": "talent",
            "on_delete": "CASCADE"
          }
        },
        "contributor_account": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ContributorAccount",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "number_of_points": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "type_of_points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NONLIQUID",
            "2": "LIQUID"
          }
        },
        "payment_order": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "PaymentOrder",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "contributor_reward": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ContributorReward",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_reason_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: reason>)"
        },
        "get_type_of_points_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: type_of_points>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "contributor account credit",
        "verbose_name_plural": "contributor account credits",
        "abstract": false,
        "db_table": "commerce_contributoraccountcredit"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "ContributorAccountCredit(id, created_at, updated_at, uuid, reason, bounty_claim, contributor_account, number_of_points, type_of_points, payment_order, contributor_reward)",
      "app_label": "commerce"
    },
    "ContributorAccountDebit": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "reason": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "LIQUIDATION",
            "2": "PUNISHMENT"
          }
        },
        "contributor_account": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "ContributorAccount",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        },
        "number_of_points": {
          "type": "PositiveIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "type_of_points": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": {
            "1": "NONLIQUID",
            "2": "LIQUID"
          }
        },
        "payment_order": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "PaymentOrder",
            "app": "commerce",
            "on_delete": "CASCADE"
          }
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_reason_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: reason>)"
        },
        "get_type_of_points_display": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.IntegerField: type_of_points>)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "contributor account debit",
        "verbose_name_plural": "contributor account debits",
        "abstract": false,
        "db_table": "commerce_contributoraccountdebit"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "ContributorAccountDebit(id, created_at, updated_at, uuid, reason, contributor_account, number_of_points, type_of_points, payment_order)",
      "app_label": "commerce"
    },
    "PointPriceConfiguration": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "created_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "updated_at": {
          "type": "DateTimeField",
          "null": true,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "uuid": {
          "type": "UUIDField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "applicable_from_date": {
          "type": "DateField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "usd_point_inbound_price_in_cents": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "eur_point_inbound_price_in_cents": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "gbp_point_inbound_price_in_cents": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "usd_point_outbound_price_in_cents": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "eur_point_outbound_price_in_cents": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "gbp_point_outbound_price_in_cents": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_next_by_applicable_from_date": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateField: applicable_from_date>, is_next=True, **kwargs)"
        },
        "get_previous_by_applicable_from_date": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateField: applicable_from_date>, is_next=False, **kwargs)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "point price configuration",
        "verbose_name_plural": "point price configurations",
        "abstract": false,
        "db_table": "commerce_pointpriceconfiguration"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "PointPriceConfiguration(id, created_at, updated_at, uuid, applicable_from_date, usd_point_inbound_price_in_cents, eur_point_inbound_price_in_cents, gbp_point_inbound_price_in_cents, usd_point_outbound_price_in_cents, eur_point_outbound_price_in_cents, gbp_point_outbound_price_in_cents)",
      "app_label": "commerce"
    }
  },
  "social_django": {
    "UserSocialAuth": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "user": {
          "type": "ForeignKey",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null,
          "references": {
            "model": "User",
            "app": "security",
            "on_delete": "CASCADE"
          }
        },
        "provider": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "uid": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "extra_data": {
          "type": "JSONField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "created": {
          "type": "DateTimeField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "modified": {
          "type": "DateTimeField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "access_token_expired": {
          "doc": "Return true / false if access token is already expired",
          "signature": "(self)"
        },
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "expiration_datetime": {
          "doc": "None",
          "signature": "(self)"
        },
        "expiration_timedelta": {
          "doc": "Return provider session live seconds. Returns a timedelta ready to\nuse with session.set_expiry().\n\nIf provider returns a timestamp instead of session seconds to live, the\ntimedelta is inferred from current time (using UTC timezone). None is\nreturned if there's no value stored or it's invalid.",
          "signature": "(self)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_access_token": {
          "doc": "Returns a valid access token.",
          "signature": "(self, strategy)"
        },
        "get_backend": {
          "doc": "None",
          "signature": "(self, strategy)"
        },
        "get_backend_instance": {
          "doc": "None",
          "signature": "(self, strategy)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_next_by_created": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: created>, is_next=True, **kwargs)"
        },
        "get_next_by_modified": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: modified>, is_next=True, **kwargs)"
        },
        "get_previous_by_created": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: created>, is_next=False, **kwargs)"
        },
        "get_previous_by_modified": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: modified>, is_next=False, **kwargs)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "refresh_token": {
          "doc": "None",
          "signature": "(self, strategy, *args, **kwargs)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "set_extra_data": {
          "doc": "None",
          "signature": "(self, extra_data=None)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [
          [
            "provider",
            "uid"
          ]
        ],
        "verbose_name": "user social auth",
        "verbose_name_plural": "user social auths",
        "abstract": false,
        "db_table": "social_auth_usersocialauth"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "Social Auth association model",
      "app_label": "social_django"
    },
    "Nonce": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "server_url": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "timestamp": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "salt": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [
          [
            "server_url",
            "timestamp",
            "salt"
          ]
        ],
        "verbose_name": "nonce",
        "verbose_name_plural": "nonces",
        "abstract": false,
        "db_table": "social_auth_nonce"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "One use numbers",
      "app_label": "social_django"
    },
    "Association": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "server_url": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "handle": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "secret": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "issued": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "lifetime": {
          "type": "IntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "assoc_type": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [
          [
            "server_url",
            "handle"
          ]
        ],
        "verbose_name": "association",
        "verbose_name_plural": "associations",
        "abstract": false,
        "db_table": "social_auth_association"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "OpenId account association",
      "app_label": "social_django"
    },
    "Code": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "email": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "code": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "verified": {
          "type": "BooleanField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "timestamp": {
          "type": "DateTimeField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_next_by_timestamp": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: timestamp>, is_next=True, **kwargs)"
        },
        "get_previous_by_timestamp": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: timestamp>, is_next=False, **kwargs)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        },
        "verify": {
          "doc": "None",
          "signature": "(self)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [
          [
            "email",
            "code"
          ]
        ],
        "verbose_name": "code",
        "verbose_name_plural": "codes",
        "abstract": false,
        "db_table": "social_auth_code"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "Code(id, email, code, verified, timestamp)",
      "app_label": "social_django"
    },
    "Partial": {
      "fields": {
        "id": {
          "type": "BigAutoField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        },
        "token": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "next_step": {
          "type": "PositiveSmallIntegerField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "backend": {
          "type": "CharField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "data": {
          "type": "JSONField",
          "null": false,
          "blank": false,
          "help_text": "",
          "choices": null
        },
        "timestamp": {
          "type": "DateTimeField",
          "null": false,
          "blank": true,
          "help_text": "",
          "choices": null
        }
      },
      "methods": {
        "adelete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "arefresh_from_db": {
          "doc": "None",
          "signature": "(self, using=None, fields=None)"
        },
        "asave": {
          "doc": "None",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "clean": {
          "doc": "Hook for doing any extra model-wide validation after clean() has been\ncalled on every field by self.clean_fields. Any ValidationError raised\nby this method will not be associated with a particular field; it will\nhave a special-case association with the field defined by NON_FIELD_ERRORS.",
          "signature": "(self)"
        },
        "clean_fields": {
          "doc": "Clean all fields and raise a ValidationError containing a dict\nof all validation errors if any occur.",
          "signature": "(self, exclude=None)"
        },
        "date_error_message": {
          "doc": "None",
          "signature": "(self, lookup_type, field_name, unique_for)"
        },
        "delete": {
          "doc": "None",
          "signature": "(self, using=None, keep_parents=False)"
        },
        "extend_kwargs": {
          "doc": "None",
          "signature": "(self, values)"
        },
        "full_clean": {
          "doc": "Call clean_fields(), clean(), validate_unique(), and\nvalidate_constraints() on the model. Raise a ValidationError for any\nerrors that occur.",
          "signature": "(self, exclude=None, validate_unique=True, validate_constraints=True)"
        },
        "get_constraints": {
          "doc": "None",
          "signature": "(self)"
        },
        "get_deferred_fields": {
          "doc": "Return a set containing names of deferred fields for this instance.",
          "signature": "(self)"
        },
        "get_next_by_timestamp": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: timestamp>, is_next=True, **kwargs)"
        },
        "get_previous_by_timestamp": {
          "doc": "None",
          "signature": "(self, *, field=<django.db.models.fields.DateTimeField: timestamp>, is_next=False, **kwargs)"
        },
        "prepare_database_save": {
          "doc": "None",
          "signature": "(self, field)"
        },
        "refresh_from_db": {
          "doc": "Reload field values from the database.\n\nBy default, the reloading happens from the database this instance was\nloaded from, or by the read router if this instance wasn't loaded from\nany database. The using parameter will override the default.\n\nFields can be used to specify which fields to reload. The fields\nshould be an iterable of field attnames. If fields is None, then\nall non-deferred fields are reloaded.\n\nWhen accessing deferred fields of an instance, the deferred loading\nof the field will call this method.",
          "signature": "(self, using=None, fields=None)"
        },
        "save": {
          "doc": "Save the current instance. Override this in a subclass if you want to\ncontrol the saving process.\n\nThe 'force_insert' and 'force_update' parameters can be used to insist\nthat the \"save\" must be an SQL insert or update (or equivalent for\nnon-SQL backends), respectively. Normally, they should not be set.",
          "signature": "(self, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "save_base": {
          "doc": "Handle the parts of saving which should be done only once per save,\nyet need to be done in raw saves, too. This includes some sanity\nchecks and signal sending.\n\nThe 'raw' argument is telling save_base not to save any parent\nmodels and not to do any changes to the values before save. This\nis used by fixture loading.",
          "signature": "(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None)"
        },
        "serializable_value": {
          "doc": "Return the value of the field name for this instance. If the field is\na foreign key, return the id value instead of the object. If there's\nno Field object with this name on the model, return the model\nattribute's value.\n\nUsed to serialize a field's value (in the serializer, or form output,\nfor example). Normally, you would just access the attribute directly\nand not use this method.",
          "signature": "(self, field_name)"
        },
        "unique_error_message": {
          "doc": "None",
          "signature": "(self, model_class, unique_check)"
        },
        "validate_constraints": {
          "doc": "None",
          "signature": "(self, exclude=None)"
        },
        "validate_unique": {
          "doc": "Check unique constraints on the model and raise ValidationError if any\nfailed.",
          "signature": "(self, exclude=None)"
        }
      },
      "meta": {
        "ordering": [],
        "unique_together": [],
        "verbose_name": "partial",
        "verbose_name_plural": "partials",
        "abstract": false,
        "db_table": "social_auth_partial"
      },
      "inheritance": {
        "type": "concrete",
        "parents": [],
        "children": []
      },
      "reverse_relations": {},
      "doc": "Partial(id, token, next_step, backend, data, timestamp)",
      "app_label": "social_django"
    }
  }
}